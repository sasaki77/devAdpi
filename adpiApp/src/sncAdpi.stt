program sncAdpi /* Program Name */

%%#include "sncAdpi.h"

unsigned int getGainFlag(unsigned short gain)
{
    if( gain == 1 ){
        return ADPI_GAIN_1;
    }else if( gain == 2 ){
        return ADPI_GAIN_2;
    }else if( gain == 4 ){
        return ADPI_GAIN_4;
    }else if( gain == 8 ){
        return ADPI_GAIN_8;
    }else if( gain == 16 ){
        return ADPI_GAIN_16;
    }else if( gain == 32 ){
        return ADPI_GAIN_32;
    }else if( gain == 64 ){
        return ADPI_GAIN_64;
    }else if( gain == 128 ){
        return ADPI_GAIN_128;
    }else{
	printf("gain = %u is not supported.\n", gain);
	printf("Check gain setting\n");
        return ADPI_GAIN_1;
    }
}

unsigned int getRateFlag(unsigned int rate)
{
    if( rate == 500 ){
        return ADPI_RATE_500;
    }else if( rate == 250 ){
        return ADPI_RATE_250;
    }else if( rate == 125 ){
        return ADPI_RATE_125;
    }else if( rate == 62 ){
        return ADPI_RATE_62;
    }else if( rate == 50 ){
        return ADPI_RATE_50;
    }else if( rate == 39 ){
        return ADPI_RATE_39;
    }else if( rate == 33 ){
        return ADPI_RATE_33;
    }else if( rate == 19 ){
        return ADPI_RATE_19;
    }else if( rate == 17 ){
        return ADPI_RATE_17;
    }else if( rate == 16 ){
        return ADPI_RATE_16;
    }else if( rate == 12 ){
        return ADPI_RATE_12;
    }else if( rate == 10 ){
        return ADPI_RATE_10;
    }else if( rate == 8 ){
        return ADPI_RATE_8;
    }else if( rate == 6 ){
        return ADPI_RATE_6;
    }else if( rate == 4 ){
        return ADPI_RATE_4;
    }else{
	printf("rate = %u is not supported.\n", rate);
	printf("Check rate setting\n");
        return ADPI_RATE_4;
    }
}

/* read ch */
unsigned long  status;
unsigned short mode;
unsigned short config;
unsigned long  data;
unsigned short num_chs;
unsigned short gain;
unsigned int   rate;

assign status  to "{head}:STATUS";
assign mode    to "{head}:MODE";
assign config  to "{head}:CONFIG";
assign data    to "{head}:DATA";
assign num_chs to "{head}:NUMCHS";
assign gain    to "{head}:SETGAIN";
assign rate    to "{head}:SETRATE";

/* write ch */
unsigned short mode_w;
unsigned short config_w;
unsigned long  update_status;
unsigned short update_mode;
unsigned short update_config;
unsigned long  update_data;
float vin[4];

assign mode_w        to "{head}:MODEw";
assign config_w      to "{head}:CONFIGw";
assign update_status to "{head}:STATUS.PROC";
assign update_mode   to "{head}:MODE.PROC";
assign update_config to "{head}:CONFIG.PROC";
assign update_data   to "{head}:DATA.PROC";
assign vin[0]        to "{head}:V1";
assign vin[1]        to "{head}:V2";
assign vin[2]        to "{head}:V3";
assign vin[3]        to "{head}:V4";

/* internal variable */
short ch;
float measure_delay;

unsigned int gain_flag;
float gain_scale;

unsigned int rate_flag;

/* State Set */
ss ss1 {
    state init {
        when () {
	    ch = 0;
	    update_config = 1;
	    update_mode   = 1;
	    update_data   = 1;
	    update_status = 1;

	    pvGet(num_chs);
	    pvGet(gain);
	    pvGet(rate);

	    gain_flag = getGainFlag(gain);
	    rate_flag = getRateFlag(rate);

	    config_w = ADPI_VBIAS_DSB | ADPI_BO_DSB | ADPI_POLAR_BI | 
		       gain_flag | ADPI_REFSEL_EXT1 | ADPI_REFDET_DSB | 
		       ADPI_BUF_DSB;

	    mode_w   = ADPI_MODE_POWERDOWN | ADPI_PSW_DSB | ADPI_AMPCM_DSB |
		       ADPI_CLK_INT1 | ADPI_CHOP_ENB | rate_flag;

	    pvPut(config_w);
	    pvPut(mode_w);

	    gain_scale = ADPI_VREF / (0x800000 * gain) ;
	    measure_delay = 2.0 * 1.0 / rate + 0.01;
	    //printf("measure_delay = %.9f\n",measure_delay);
	    //printf("gain_scale = %.9f\n",gain_scale);
	} state init_measure
    }

    state init_measure {
        entry {
            //printf("sncAdpi: Init Measure\n");
	    config_w = (config_w & 0xfff8) | (ch & 0x0007);
	    mode_w = (mode_w & 0x1fff) | ADPI_MODE_SINGLE;
	    pvPut(config_w, SYNC);
	    pvPut(mode_w, SYNC);

	    pvPut(update_config);
	    pvPut(update_mode);
        }
        when ( delay(measure_delay) ) {
	    pvPut(update_status, SYNC);
	    pvGet(status);
        } state wait_measure
    }

    state wait_measure {
	when ( !(status & ADPI_STS_RDY) ) {
            //printf("sncAdpi: Measure complete\n");
	    pvPut(update_data, SYNC);
	} state measure
        when ( delay(measure_delay) ) {
            //printf("sncAdpi: Measure wait\n");
	    pvPut(update_status, SYNC);
	    pvGet(status);
        } state wait_measure 
    }

    state measure {
        entry {
	    pvGet(data);
            if(ch <= ADPI_CH_4) {
	        vin[ch] = gain_scale * (long)(data - ADPI_BI_OFFSET);
	        //printf("v%u = %f\n",ch,v1);
	        pvPut(vin[ch]);
	    }else{
	        printf("measure error on ch%u\n",ch);
	    }
        }
        when () {
            //printf("sncAdpi: End\n");
	    ch = (ch >= (num_chs-1))? 0 : ch+1;
        } state init_measure
    }
}
